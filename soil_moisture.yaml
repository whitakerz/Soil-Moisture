########## THIS VERSION DID COMPILE BEFORE 2AM 10/10/25 ##############################

# Code Parts Used From https://github.com/hanspeda/esphome_homeassistant_display.git
# Code Assistance Provided by OpenAI codex

# -----------------------------------------------------------------------------
# Global substitution values used throughout the configuration. Adjusting these
# settings allows the device runtime and sleep intervals to be tuned without
# touching the rest of the file. A dedicated low-battery daytime interval keeps
# Wi-Fi performance high while still stretching runtimes.
# -----------------------------------------------------------------------------
substitutions:
  run_time: 20s
  sleep_time: 30min
  low_battery_sleep_time: 60min
  night_sleep_time: 6h

# Core ESPHome configuration and boot sequence. The on_boot logic ensures the
# device gathers sensor data before entering deep sleep when running on
# battery-only power.
esphome:
  name: planter
  friendly_name: Planter
  on_boot:
    priority: 800
    then:
      - deep_sleep.prevent: deep_sleep_ctrl
      # Sample the 5V rail immediately so voltage telemetry remains available
      # even though the device now always follows the low-power workflow.
      - component.update: adc_5v_raw
      - logger.log: "Running unified low-power workflow."
      # The deep-sleep timer is already paused; hand off to the battery boot
      # script so it can connect, publish, and then re-enable sleep once the
      # data has landed in Home Assistant.
      - script.execute: handle_battery_boot



# Logging is kept at INFO level with UART disabled to reduce active-time power
# draw while still surfacing important events.
logger:
  level: INFO
  baud_rate: 0

# ESP32 hardware configuration. The CPU frequency is reduced to save power
# during battery operation.
esp32:
  board: esp32dev
  framework:
    type: esp-idf
  cpu_frequency: 80MHz


api:
  id: homeassistant_api
  encryption:
    key: !secret soilapi


ota:
  - platform: esphome
    password: "af02dabd1a628b113fb6ffc6c6a94c17"

# Primary Wi-Fi connection along with a fallback access point to assist with
# provisioning should the device be unable to join the main network. Power save
# is disabled and the output power is driven high to maintain a distant link.
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: 192.168.7.105
    gateway: 192.168.7.1
    subnet: 255.255.255.0
  power_save_mode: NONE
  output_power: 20dB
  fast_connect: true
  ap:
    ssid: "Soil Fallback Hotspot"
    password: "BDVDN7O0KT7E"

captive_portal:

# I2C bus that hosts the SHT31 sensor.
i2c:
  sda: 21
  scl: 22
  scan: false
  id: bus_a

sensor:
  # SHT31 temperature and humidity readings. Automatic polling is disabled so
  # that manual updates only occur when required, trimming awake time.
  - platform: sht3xd
    id: sht31_sensor
    address: 0x44
    update_interval: never
    temperature:
      name: "Planter Temperature"
      id: sht31_temperature
      force_update: true
    humidity:
      name: "Soil Water Level"
      id: sht31_humidity
      force_update: true

  - platform: sht3xd
    id: box_sht31_sensor
    address: 0x45
    update_interval: never
    temperature:
      name: "Box Temperature"
      id: box_temperature
      force_update: true
    humidity:
      name: "Box Humidity"
      id: box_humidity
      force_update: true

  # Raw ADC reading of the 5V input, kept internal for derived sensors and only
  # sampled on-demand.
  - platform: adc
    id: adc_5v_raw
    name: "ADC Pin Voltage (GPIO36)"
    pin: GPIO36
    attenuation: 12db
    update_interval: never
    accuracy_decimals: 3
    internal: true

  - platform: copy
    source_id: adc_5v_raw
    id: source_voltage
    name: "5V"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - multiply: 1.8
    on_value:
      then:
        - lambda: |-
            static bool present = false;
            if (!present && x > 4.0) present = true;
            else if (present && x < 3.0) present = false;
            id(voltage_present).publish_state(present);

  # Raw ADC reading of the Li-Ion battery which is scaled below to volts and
  # percentage. Like the 5V channel, this is sampled only when necessary to
  # avoid wasted conversions.
  - platform: adc
    id: adc_batt_raw
    name: "ADC Pin Voltage (GPIO32)"
    pin: GPIO32
    attenuation: 12db
    update_interval: never
    accuracy_decimals: 3
    internal: true

  - platform: copy
    source_id: adc_batt_raw
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    force_update: true
    filters:
      - multiply: 1.36

  - platform: copy
    source_id: battery_voltage
    id: battery_percent
    name: "Battery %"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    force_update: true
    filters:
      - calibrate_linear:
          - 4.2 -> 100
          - 4.00 -> 85
          - 3.85 -> 60
          - 3.80 -> 50
          - 3.70 -> 25
          - 3.50 -> 5
          - 3.30 -> 0
      - lambda: |-
          if (x < 0) x = 0;
          if (x > 100) x = 100;
          return x;

  - platform: wifi_signal
    id: wifi_signal_dbm
    name: "WiFi Signal"
    update_interval: 60s
    entity_category: diagnostic
    filters:
      - delta: 1

  # Derived Wi-Fi signal percentage to give a user-friendly representation in
  # dashboards.
  - platform: copy
    source_id: wifi_signal_dbm
    name: "WiFi Signal (%)"
    unit_of_measurement: "%"
    device_class: signal_strength
    entity_category: diagnostic
    accuracy_decimals: 0
    filters:
      - lambda: |-
          const float RSSI_MIN = -90.0f;
          const float RSSI_MAX = -30.0f;
          float percent = (x - RSSI_MIN) / (RSSI_MAX - RSSI_MIN) * 100.0f;
          if (percent < 0.0f) percent = 0.0f;
          if (percent > 100.0f) percent = 100.0f;
          return percent;
      - sliding_window_moving_average:
          window_size: 4
          send_every: 1

binary_sensor:
  # Indicates whether external 5V power is present; used to decide between
  # normal updates and the low-power workflow.
  - platform: template
    id: voltage_present
    name: "Voltage Present"
    internal: true
    device_class: power
    filters:
      - delayed_on: 100ms
      - delayed_off: 300ms

globals:
  - id: last_event_text
    type: std::string
    restore_value: yes
    initial_value: '"none"'

text_sensor:
  - platform: template
    name: "Planter Last Event"
    id: last_event
    update_interval: never
    lambda: |-
      return std::string(id(last_event_text).c_str());
    on_value:
      then:
        - lambda: |-
            id(last_event_text) = x;
            ESP_LOGI("main", "Event stored: %s", x.c_str());




time:
  - platform: homeassistant
    id: home_time

# Sleep management script differentiating between day and night to conserve
# battery life.
script:
  - id: handle_battery_boot
    mode: restart
    then:
      - logger.log: "On battery, waiting for Wi-Fi and sensors."
      - wait_until:
          condition:
            wifi.connected:
          timeout: 30s
      - logger.log: "Wi-Fi connected or timeout reached."
      - wait_until:
          condition:
            api.connected:
          timeout: 15s
      - logger.log: "Network ready, reading sensors."
      - component.update: sht31_sensor
      - component.update: box_sht31_sensor
      - component.update: wifi_signal_dbm
      - component.update: adc_batt_raw
      - component.update: adc_5v_raw
      - wait_until:
          condition:
            lambda: |-
              return id(sht31_temperature).has_state() &&
                     id(sht31_humidity).has_state() &&
                     id(box_temperature).has_state() &&
                     id(battery_voltage).has_state();
      - delay: 750ms
      - logger.log: "Publishing complete, entering sleep."
      - script.execute: enter_sleep

  - id: enter_sleep
    then:
      - lambda: |-
          auto now = id(home_time).now();
          std::string reason;

          if (!now.is_valid()) reason = "invalid_time";
          else if (now.hour >= 22) reason = "night";
          else if (id(battery_percent).has_state() && id(battery_percent).state <= 30.0f)
            reason = "day_low_battery";
          else
            reason = "day_normal";

          char buffer[128];
          snprintf(buffer, sizeof(buffer),
                   "Sleep reason: %s at %s, battery: %.0f%%",
                   reason.c_str(),
                   now.strftime("%Y-%m-%d %H:%M:%S").c_str(),
                   id(battery_percent).state);
          id(last_event).publish_state(buffer);
          id(last_event_text) = buffer;
          // DEBUG: TO PREVENT DUPLICATE LOG ENTRIES, COMMENT OUT THE BELOW LINE ///////////////
          // ESP_LOGI("main", "Event stored: %s", buffer);      

      - if:
          condition: # time after 21:00 (9pm)
            lambda: |-
              auto t = id(home_time).now();
              return (t.is_valid() && t.hour >= 21);
          then:
            - homeassistant.event:
                event: esphome.planter_sleep
                data:
                  device: battery
                  reason: "night"
                  duration: "${night_sleep_time}"
                  battery_percent: !lambda 'return id(battery_percent).state;'
                  now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
            - deep_sleep.allow: deep_sleep_ctrl
            - delay: 250ms
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                sleep_duration: ${night_sleep_time}

          else: # battery out of charge, extend sleep time to save battery
            - if:
                condition:
                  lambda: |-
                    return id(battery_percent).has_state() &&
                           id(battery_percent).state <= 30.0f;
                then:
                  - homeassistant.event:
                      event: esphome.planter_sleep
                      data:
                        device: battery
                        reason: "day_low_battery"
                        duration: "${low_battery_sleep_time}"
                        battery_percent: !lambda 'return id(battery_percent).state;'
                        now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
                  - deep_sleep.allow: deep_sleep_ctrl
                  - delay: 250ms
                  - deep_sleep.enter:
                      id: deep_sleep_ctrl
                      sleep_duration: ${low_battery_sleep_time}

                else: # normal battery sleep
                  - homeassistant.event:
                      event: esphome.planter_sleep
                      data:
                        device: battery
                        reason: "day_normal"
                        duration: "${sleep_time}"
                        battery_percent: !lambda 'return id(battery_percent).state;'
                        now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
                  - deep_sleep.allow: deep_sleep_ctrl
                  - delay: 250ms
                  - deep_sleep.enter:
                      id: deep_sleep_ctrl
                      sleep_duration: ${sleep_time}


interval:
  - interval: 30s
    then:
      - component.update: sht31_sensor
      - component.update: box_sht31_sensor
      - component.update: adc_5v_raw
      - component.update: adc_batt_raw

# Deep sleep controller that governs wake durations and responds to the
# external wake pin.
deep_sleep:
  id: deep_sleep_ctrl
  run_duration: ${run_time}
  sleep_duration: ${sleep_time}
  wakeup_pin: GPIO39
  wakeup_pin_mode: KEEP_AWAKE