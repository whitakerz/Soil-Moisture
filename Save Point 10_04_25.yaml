substitutions:
  run_time: 30s
  sleep_time: 5min
  night_sleep_time: 8h

esphome:
  name: sht31_sensor
  friendly_name: Soil
  on_boot:
    priority: -10
    then:
      - lambda: |-
          Wire.begin();
          delay(100);
      - if:
          condition:
            binary_sensor.is_on: voltage_present
          then:
            - logger.log: "5V present, staying awake and updating every 30s."
          else:
            - logger.log: "On battery, waiting for Wi-Fi and sensors."
            - wait_until:
                condition:
                  wifi.connected:
            - wait_until:
                condition:
                  api.connected:
            - logger.log: "Network ready, reading sensors."
            - component.update: sht31_sensor
            - component.update: adc_batt_raw
            - component.update: adc_5v_raw
            - wait_until:
                condition:
                  lambda: |-
                    return id(sht31_temperature).has_state() &&
                           id(sht31_humidity).has_state() &&
                           id(battery_voltage).has_state();
            - logger.log: "Publishing complete, entering sleep."
            - delay: 1s
            - script.execute: enter_sleep



logger:
  level: DEBUG

esp32:
  board: esp32dev
  framework:
    type: arduino
  cpu_frequency: 80MHz

api:
  encryption:
    key: !secret soilapi

ota:
  - platform: esphome
    password: "af02dabd1a628b113fb6ffc6c6a94c17"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: 192.168.7.105
    gateway: 192.168.7.1
    subnet: 255.255.255.0
  power_save_mode: LIGHT
  ap:
    ssid: "Soil Fallback Hotspot"
    password: "BDVDN7O0KT7E"

captive_portal:

i2c:
  sda: 21
  scl: 22
  scan: false
  id: bus_a

sensor:
  - platform: sht3xd
    id: sht31_sensor
    address: 0x44
    temperature:
      name: "SHT31 Temperature"
      id: sht31_temperature
      force_update: true
    humidity:
      name: "SHT31 Humidity"
      id: sht31_humidity
      force_update: true

  - platform: adc
    id: adc_5v_raw
    name: "ADC Pin Voltage (GPIO36)"
    pin: GPIO36
    attenuation: 12db
    update_interval: 30s
    accuracy_decimals: 3
    internal: true

  - platform: copy
    source_id: adc_5v_raw
    id: source_voltage
    name: "5V"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - multiply: 1.8
    on_value:
      then:
        - lambda: |-
            static bool present = false;
            if (!present && x > 4.0) present = true;
            else if (present && x < 3.0) present = false;
            id(voltage_present).publish_state(present);

  - platform: adc
    id: adc_batt_raw
    name: "ADC Pin Voltage (GPIO32)"
    pin: GPIO32
    attenuation: 12db
    update_interval: 30s
    accuracy_decimals: 3
    internal: true

  - platform: copy
    source_id: adc_batt_raw
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    force_update: true
    filters:
      - multiply: 1.36

  - platform: copy
    source_id: battery_voltage
    id: battery_percent
    name: "Battery %"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    force_update: true
    filters:
      - calibrate_linear:
          - 4.18 -> 100
          - 4.00 -> 85
          - 3.85 -> 60
          - 3.80 -> 50
          - 3.70 -> 25
          - 3.50 -> 5
          - 3.30 -> 0
      - lambda: |-
          if (x < 0) x = 0;
          if (x > 100) x = 100;
          return x;

  - platform: wifi_signal
    id: wifi_signal_dbm
    name: "WiFi Signal"
    update_interval: 60s
    entity_category: diagnostic
    filters:
      - delta: 1

  - platform: copy
    source_id: wifi_signal_dbm
    name: "WiFi Signal (%)"
    unit_of_measurement: "%"
    device_class: signal_strength
    entity_category: diagnostic
    accuracy_decimals: 0
    filters:
      - lambda: |-
          const float RSSI_MIN = -90.0f;
          const float RSSI_MAX = -30.0f;
          float percent = (x - RSSI_MIN) / (RSSI_MAX - RSSI_MIN) * 100.0f;
          if (percent < 0.0f) percent = 0.0f;
          if (percent > 100.0f) percent = 100.0f;
          return percent;
      - sliding_window_moving_average:
          window_size: 4
          send_every: 1

binary_sensor:
  - platform: template
    id: voltage_present
    name: "Voltage Present"
    internal: true
    device_class: power
    filters:
      - delayed_on: 100ms
      - delayed_off: 300ms

time:
  - platform: homeassistant
    id: home_time

script:
  - id: enter_sleep
    then:
      - if:
          condition:
            lambda: |-
              auto time = id(home_time).now();
              if (!time.is_valid()) return false;
              return (time.hour >= 21);
          then:
            - logger.log: "It's nighttime, entering long sleep."
            - homeassistant.event:
                event: esphome.battery_sleep
                data:
                  device: battery
                  reason: "night"
                  duration: "${night_sleep_time}"
                  voltage: !lambda 'return id(battery_voltage).state;'
                  now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                sleep_duration: "${night_sleep_time}"
          else:
            - logger.log: "It's daytime, entering short sleep."
            - homeassistant.event:
                event: esphome.battery_sleep
                data:
                  device: battery
                  reason: "day"
                  duration: "${sleep_time}"
                  voltage: !lambda 'return id(battery_voltage).state;'
                  now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                sleep_duration: "${sleep_time}"

interval:
  - interval: 30s
    then:
      - if:
          condition:
            binary_sensor.is_on: voltage_present
          then:
            - component.update: sht31_sensor
            - component.update: adc_5v_raw
            - component.update: adc_batt_raw

deep_sleep:
  id: deep_sleep_ctrl
  run_duration: ${run_time}
  sleep_duration: ${sleep_time}
  wakeup_pin: GPIO39
  wakeup_pin_mode: KEEP_AWAKE
