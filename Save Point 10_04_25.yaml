substitutions:
  # Primary timing controls. Adjust these to balance responsiveness and
  # power consumption. Shorter run times and longer sleep durations will
  # extend battery life at the expense of slower updates.
  sleep_time: 3min
  run_time: 1min
  night_sleep_time: 8h

esphome:
  name: sht31_sensor
  friendly_name: Soil
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // Ensure the I2C bus starts cleanly before any sensor updates.
          Wire.begin();
          // Allow time for sensors to power up fully before polling.
          delay(100);
      - script.execute: enter_sleep          


logger:
  # Lower the log level to reduce serial output overhead while still
  # retaining warnings and errors for diagnostics. Set back to DEBUG
  # temporarily when actively troubleshooting.
  level: WARN

esp32:
  board: esp32dev
  framework:
    type: arduino
  cpu_frequency: 80MHz

api:
  encryption:
    key: !secret soilapi  

ota:
  - platform: esphome
    password: "af02dabd1a628b113fb6ffc6c6a94c17"

# WiFi setup
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: 192.168.7.105 # ðŸ‘ˆ Replace with your desired static IP
    gateway: 192.168.7.1     # ðŸ‘ˆ Replace with your router's IP
    subnet: 255.255.255.0    # ðŸ‘ˆ Your network's subnet mask
  # Enable Wi-Fi power save to lower consumption between transmissions.
  power_save_mode: LIGHT
  ap:
    ssid: "Soil Fallback Hotspot"
    password: "BDVDN7O0KT7E"

captive_portal:


# I2C bus
i2c:
  sda: 21
  scl: 22
  # Disable continuous scanning after development to shorten boot time and
  # reduce unnecessary bus activity. Re-enable if you are adding new devices.
  scan: false
  id: bus_a

# Environmental sensors
sensor:
  - platform: sht3xd
    i2c_id: bus_a
    address: 0x44
    temperature:
      id: sht31_temperature
      name: "SHT31 Temperature"
      device_class: temperature
      state_class: measurement
      unit_of_measurement: "Â°C"
      accuracy_decimals: 2
    humidity:
      id: sht31_humidity
      name: "SHT31 Humidity"
      device_class: humidity
      state_class: measurement
      unit_of_measurement: "%"
      accuracy_decimals: 2

    # ----- 5V sense (pre-divider) -----
  - platform: adc
    id: adc_5v_raw
    # Monitor the input rail before the divider to detect USB power.
    name: "ADC Pin Voltage (GPIO36)"
    pin: GPIO36
    attenuation: 12db
    update_interval: 5min
    accuracy_decimals: 3
    internal: true

  - platform: copy
    source_id: adc_5v_raw
    id: source_voltage
    # Convert the divided reading to the actual 5 V rail voltage.
    name: "5V"
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - multiply: 1.8
    on_value:
      then:
        - lambda: |-
            // Simple hysteresis to prevent rapid toggling when the 5 V rail
            // hovers near the threshold.
            static bool present = false;
            if (!present && x > 4.0) present = true;
            else if (present && x < 3.0) present = false;
            id(voltage_present).publish_state(present);

  # ----- LiPo battery voltage -----
  - platform: adc
    id: adc_batt_raw
    # Raw battery ADC reading used to derive voltage and percentage.
    name: "ADC Pin Voltage (GPIO32)"
    pin: GPIO32
    attenuation: 12db
    update_interval: 5min
    accuracy_decimals: 3
    internal: true

  - platform: copy
    source_id: adc_batt_raw
    id: battery_voltage
    # Scale the raw ADC reading to the actual LiPo voltage.
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 1.36
  
  - platform: copy
    source_id: battery_voltage
    id: battery_percent
    name: "Battery %"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    filters:
      # Nonlinear-ish LiPo curve (tweak to your cell)
      - calibrate_linear:
          - 4.18 -> 100
          - 4.00 -> 85
          - 3.85 -> 60
          - 3.80 -> 50
          - 3.70 -> 25
          - 3.50 -> 5
          - 3.30 -> 0
      # Clamp and smooth
      - lambda: |-
          // Clamp noisy readings before smoothing so that the moving average
          // never reports out-of-range percentages.
          if (x < 0) x = 0;
          if (x > 100) x = 100;
          return x;
      - sliding_window_moving_average:
          window_size: 4
          send_every: 1     

binary_sensor:
  - platform: template
    id: voltage_present
    name: "Voltage Present"
    internal: true
    device_class: power
    filters:
      - delayed_on: 100ms
      - delayed_off: 300ms
    on_release:
      then:
        - logger.log: "Voltage lost â€” entering deep sleep."
        #- light.turn_off: awake_led
        - deep_sleep.enter: deep_sleep_ctrl
    # Virtual sensor that reflects whether external 5 V power is present.
    # Used to gate energy-intensive tasks when the device is battery-only.

time:
  - platform: homeassistant
    id: home_time
    # Pull time from Home Assistant so that sleep decisions stay aligned with
    # your household schedule even after long deep-sleep intervals.


script:
  - id: enter_sleep
    # Decide between short daytime naps and extended overnight sleeps.
    then:
      - if:
          condition:
            lambda: |-
              auto time = id(home_time).now();
              if (!time.is_valid()) return false;
              return (time.hour >= 21);
          then:
            - logger.log: "It's nighttime, entering long sleep for ${night_sleep_time}"
            ### THIS IS LOGGING IN HOME ASSISTANT ###
            - homeassistant.event:
                event: esphome.battery_sleep
                data:
                  device: battery
                  reason: "night"
                  duration: "${night_sleep_time}"
                  voltage: !lambda 'return id(battery_voltage).state;'
                  now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
            ### TO HERE ###
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                sleep_duration: ${night_sleep_time}
          else:
            - logger.log: "It's daytime, entering short sleep for ${sleep_time}"
            ### THIS IS LOGGING IN HOME ASSISTANT ###
            - homeassistant.event:
                event: esphome.battery_sleep
                data:
                  device: battery
                  reason: "day"
                  duration: "${sleep_time}"
                  voltage: !lambda 'return id(battery_voltage).state;'
                  now: !lambda 'return id(home_time).now().strftime("%Y-%m-%d %H:%M:%S");'
            ### TO HERE ###
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                sleep_duration: ${sleep_time}
interval:
  #- interval: 5s
  #  then:
  #    - component.update: adc_5v_raw
  #    - component.update: adc_batt_raw

  - interval: 2min
    then:
      - if:
          condition:
            binary_sensor.is_on: voltage_present
          then:
            # Only refresh ADC readings when external power is available to
            # avoid unnecessary wake-time when running from battery.
            - component.update: adc_5v_raw
            - component.update: adc_batt_raw


deep_sleep:
  id: deep_sleep_ctrl
  run_duration: ${run_time}
  sleep_duration: ${sleep_time}
  wakeup_pin: GPIO39
  # KEEP_AWAKE ensures the device stays awake while the wake pin is asserted,
  # which is useful when tethered to external power.
  wakeup_pin_mode: KEEP_AWAKE
